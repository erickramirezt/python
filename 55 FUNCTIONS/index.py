# PYTHON FUNCTIONS

# A FUNCTION IS A BLOCK OF CODE WHICH ONLY RUNS WHEN IT IS CALLED.
# YOU CAN PASS DATA, KNOWN AS PARAMETERS, INTO A FUNCTION.
# A FUNCTION CAN RETURN DATA AS A RESULT.

# CREATING A FUNCTION
# IN PYTHON A FUNCTION IS DEFINED USING THE DEF KEYWORD:

# EXAMPLE
def my_function():
    print("Hello from a function")

# CALLING A FUNCTION
# TO CALL A FUNCTION, USE THE FUNCTION NAME FOLLOWED BY PARENTHESIS:

# EXAMPLE


def my_function():
    print("Hello from a function")


my_function()

# ARGUMENTS
# INFORMATION CAN BE PASSED INTO FUNCTIONS AS ARGUMENTS.
# ARGUMENTS ARE SPECIFIED AFTER THE FUNCTION NAME, INSIDE THE PARENTHESES. YOU CAN ADD AS MANY ARGUMENTS AS YOU
# WANT, JUST SEPARATE THEM WITH A COMMA.
# THE FOLLOWING EXAMPLE HAS A FUNCTION WITH ONE ARGUMENT (FNAME). WHEN THE FUNCTION IS CALLED, WE PASS ALONG A
# FIRST NAME, WHICH IS USED INSIDE THE FUNCTION TO PRINT THE FULL NAME:

# EXAMPLE


def my_function(fname):
    print(fname + " Refsnes")


my_function("Emil")
my_function("Tobias")
my_function("Linus")

# ARGUMENTS ARE OFTEN SHORTENED TO ARGS IN PYTHON DOCUMENTATION.

# PARAMETERS OR ARGUMENTS?
# THE TERMS PARAMETER AND ARGUMENT CAN BE USED FOR THE SAME THING: INFORMATION THAT ARE PASSED INTO A FUNCTION.

# FROM A FUNCTION'S PERSPECTIVE:
# A PARAMETER IS THE VARIABLE LISTED INSIDE THE PARENTHESES IN THE FUNCTION DEFINITION.
# AN ARGUMENT IS THE VALUE THAT IS SENT TO THE FUNCTION WHEN IT IS CALLED.

# NUMBER OF ARGUMENTS
# BY DEFAULT, A FUNCTION MUST BE CALLED WITH THE CORRECT NUMBER OF ARGUMENTS. MEANING THAT IF YOUR FUNCTION
# EXPECTS 2 ARGUMENTS, YOU HAVE TO CALL THE FUNCTION WITH 2 ARGUMENTS, NOT MORE, AND NOT LESS.

# EXAMPLE
# THIS FUNCTION EXPECTS 2 ARGUMENTS, AND GETS 2 ARGUMENTS:


def my_function(fname, lname):
    print(fname + " " + lname)


my_function("Emil", "Refsnes")

# IF YOU TRY TO CALL THE FUNCTION WITH 1 OR 3 ARGUMENTS, YOU WILL GET AN ERROR:

# EXAMPLE
# THIS FUNCTION EXPECTS 2 ARGUMENTS, BUT GETS ONLY 1:

# def my_function(fname, lname):
#     print(fname + " " + lname)

# my_function("Emil")

# ARBITRARY ARGUMENTS, *ARGS
# IF YOU DO NOT KNOW HOW MANY ARGUMENTS THAT WILL BE PASSED INTO YOUR FUNCTION, ADD A * BEFORE THE PARAMETER
# NAME IN THE FUNCTION DEFINITION.
# THIS WAY THE FUNCTION WILL RECEIVE A TUPLE OF ARGUMENTS, AND CAN ACCESS THE ITEMS ACCORDINGLY:

# EXAMPLE
# IF THE NUMBER OF ARGUMENTS IS UNKNOWN, ADD A * BEFORE THE PARAMETER NAME:


def my_function(*kids):
    print("The youngest child is " + kids[2])


my_function("Emil", "Tobias", "Linus")

# ARBITRARY ARGUMENTS ARE OFTEN SHORTENED TO *ARGS IN PYTHON DOCUMENTATION.

# KEYWORD ARGUMENTS
# YOU CAN ALSO SEND ARGUMENTS WITH THE KEY = VALUE SYNTAX.
# THIS WAY THE ORDER OF THE ARGUMENTS DOES NOT MATTER.

# EXAMPLE


def my_function(child3, child2, child1):
    print("The youngest child is " + child3)


my_function(child1="Emil", child2="Tobias", child3="Linus")

# THE PHRASE KEYWORD ARGUMENTS ARE OFTEN SHORTENED TO KWARGS IN PYTHON DOCUMENTATION.

# ARBITRARY KEYWORD ARGUMENTS, **KWARGS
# IF YOU DO NOT KNOW HOW MANY KEYWORD ARGUMENTS THAT WILL BE PASSED INTO YOUR FUNCTION, ADD TWO ASTERISK: **
# BEFORE THE PARAMETER NAME IN THE FUNCTION DEFINITION.
# THIS WAY THE FUNCTION WILL RECEIVE A DICTIONARY OF ARGUMENTS, AND CAN ACCESS THE ITEMS ACCORDINGLY:

# EXAMPLE
# IF THE NUMBER OF KEYWORD ARGUMENTS IS UNKNOWN, ADD A DOUBLE ASTERISK ** BEFORE THE PARAMETER NAME:


def my_function(**kid):
    print("His last name is " + kid["lname"])


my_function(fname="Tobias", lname="Refsnes")

# ARBITRARY KEYWORD ARGUMENTS ARE OFTEN SHORTENED TO **KWARGS IN PYTHON DOCUMENTATION.

# DEFAULT PARAMETER VALUE
# THE FOLLOWING EXAMPLE SHOWS HOW TO USE A DEFAULT PARAMETER VALUE.
# IF WE CALL THE FUNCTION WITHOUT ARGUMENTS, IT USES THE DEFAULT VALUE:

# EXAMPLE


def my_function(country="Norway"):
    print("I am from " + country)


my_function("Sweden")
my_function("India")
my_function()
my_function("Brazil")

# PASSING A LIST AS AN ARGUMENT
# YOU CAN SEND ANY DATA TYPES OF ARGUMENT TO A FUNCTION (STRING, NUMBER, LIST, DICTIONARY ETC.), AND IT WILL BE
# TREATED AS THE SAME DATA TYPE INSIDE THE FUNCTION.
# E.G. IF YOU SEND A LIST AS AN ARGUMENT, IT WILL STILL BE A LIST WHEN IT REACHES THE FUNCTION:

# EXAMPLE


def my_function(food):
    for x in food:
        print(x)


fruits = ["apple", "banana", "cherry"]

my_function(fruits)

# RETURN VALUES
# TO LET A FUNCTION RETURN A VALUE, USE THE RETURN STATEMENT:

# EXAMPLE


def my_function(x):
    return 5 * x


print(my_function(3))
print(my_function(5))
print(my_function(9))

# THE PASS STATEMENT
# FUNCTION DEFINITIONS CANNOT BE EMPTY, BUT IF YOU FOR SOME REASON HAVE A FUNCTION DEFINITION WITH NO CONTENT,
# PUT IN THE PASS STATEMENT TO AVOID GETTING AN ERROR.

# EXAMPLE


def myfunction():
    pass

# RECURSION
# PYTHON ALSO ACCEPTS FUNCTION RECURSION, WHICH MEANS A DEFINED FUNCTION CAN CALL ITSELF.

# RECURSION IS A COMMON MATHEMATICAL AND PROGRAMMING CONCEPT. IT MEANS THAT A FUNCTION CALLS ITSELF. THIS HAS THE
# BENEFIT OF MEANING THAT YOU CAN LOOP THROUGH DATA TO REACH A RESULT.

# THE DEVELOPER SHOULD BE VERY CAREFUL WITH RECURSION AS IT CAN BE QUITE EASY TO SLIP INTO WRITING A FUNCTION
# WHICH NEVER TERMINATES, OR ONE THAT USES EXCESSIVE AMOUNTS OF MEMORY OR PROCESSOR POWER. HOWEVER, WHEN WRITTEN
# CORRECTLY RECURSION CAN BE A VERY EFFICIENT AND MATHEMATICALLY-ELEGANT APPROACH TO PROGRAMMING.

# IN THIS EXAMPLE, TRIPIAL RECURSION IS USED TO CALCULATE THE SUM OF A NATURAL NUMBER. WE USE THE K VARIABLE AS
# THE DATA, WHICH DECREMENTS (-1) EVERY TIME WE RECURSE. THE RECURSION ENDS WHEN THE CONDITION IS NOT GREATER
# THAN 0 (WHEN IT IS 0).

# TO A NEW DEVELOPER IT CAN TAKE SOME TIME TO WORK OUT HOW EXACTLY THIS WORKS, BEST WAY TO FIND OUT IS BY TESTING
# AND MODIFYING IT.

# EXAMPLE
# RECUSION EXAMPLE


def tri_recursion(k):
    if (k > 0):
        result = k + tri_recursion(k - 1)
        print(result)
    else:
        result = 0
    return result


print("\n\nRecursion Example Results")
tri_recursion(6)
